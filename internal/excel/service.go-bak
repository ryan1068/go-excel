package excel

import (
	"context"
	"encoding/json"
	"cst/internal/pkg/config"
	"cst/pkg/request"
	"cst/pkg/utils"
	"fmt"
	"github.com/go-redis/redis/v8"
	"github.com/tidwall/gjson"
	"github.com/xuri/excelize/v2"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
	"io"
	"math"
	"net/http"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

var ctx = context.Background()

type Service struct {
	Form    *ImportForm
	cfg     *config.Config
	redis   *redis.Client
	mongodb *mgo.Database
}

type Result struct {
	row []string
	res []gjson.Result
	err error
}

func (s *Service) createTask() (string, error) {

	f := func() (string, [][]string, string, error) {
		filePath, err := s.downloadExcel()
		if err != nil {
			return "", nil, "", err
		}

		f, err := excelize.OpenFile(filePath)
		if err != nil {
			return "", nil, "", err
		}
		// Get all the rows in the Sheet1.
		rows, err := f.GetRows("Sheet1")
		if err != nil {
			return "", nil, "", err
		}

		mapping := strings.Split(s.Form.Mapping, ",")
		if len(mapping) != len(rows[0]) {
			return "", nil, "", fmt.Errorf("上传Excel中表头设置不正确")
		}

		if len(rows) > 5000 {
			return "", nil, "", fmt.Errorf("上传文件中总行数不能大于5000条")
		}

		apiHost := s.getApiHost(s.Form.ApiHost)
		if apiHost == nil {
			return "", nil, "", fmt.Errorf("apiHost传参不正确")
		}

		taskId := utils.RandStringBytes(10)
		return filePath, rows, taskId, nil
	}

	filePath, rows, taskId, logId, err := s.log(f)
	if err != nil {
		return "", err
	}
	go s.importExcel(filePath, rows, taskId, logId)

	return taskId, nil
}

// 导入excel文件
func (s *Service) importExcel(filePath string, rows [][]string, taskId string, logId bson.ObjectId) error {
	validRows := s.handleRows(rows)
	totalRow := len(validRows)
	newFile := excelize.NewFile()
	index := newFile.NewSheet("Sheet1")
	if err := s.generateHeader(rows[0], newFile); err != nil {
		return err
	}

	cacheKey := s.cacheKey(s.Form.ApiParams["group_id"], s.Form.ApiParams["area_id"], s.Form.TaskType)
	s.redis.Set(ctx, cacheKey, taskId, time.Second*3600*2)
	s.redis.Del(ctx, taskId)
	s.redis.HSet(ctx, taskId, "count", totalRow)
	s.redis.Expire(ctx, taskId, time.Second*3600*2)

	// 防止单次并发量过大，把总数据量分成多个任务执行
	perTask := 10                                                // 单次任务执行的数据量
	taskCount := math.Ceil(float64(totalRow) / float64(perTask)) // 总任务数
	taskIndex := 1                                               // 任务索引
	excelErrRow := 1                                             // 定位失败数据excel行数

	for i := 0; i < totalRow; i += perTask {

		var sliceRows [][]string
		if taskIndex == int(taskCount) {
			// last task
			sliceRows = validRows[i:totalRow]
		} else {
			sliceRows = validRows[i : taskIndex*perTask]
		}

		doneChan := make(chan Result)
		for _, row := range sliceRows {
			go s.Do(row, doneChan)
		}

		for i := 1; i <= len(sliceRows); i++ {
			select {
			case ch, _ := <-doneChan:
				if ch.err != nil {
					s.redis.HIncrBy(ctx, taskId, "failCount", 1)
					excelErrRow++
					for col, value := range ch.row {
						axis := s.getExcelDataAxis(col+1, excelErrRow)
						newFile.SetCellValue("Sheet1", axis, value)
					}
					axis := s.getExcelDataAxis(len(rows[0])+1, excelErrRow)
					newFile.SetCellValue("Sheet1", axis, ch.err)
					newFile.SetActiveSheet(index)
				} else {
					s.redis.HIncrBy(ctx, taskId, "successCount", 1)
				}

				if i == totalRow {
					if excelErrRow > 1 {
						errorFile, err := s.createErrorFile(filePath)
						if err != nil {
							return err
						}
						base := strings.TrimLeft(errorFile, "/www/runtime/go-excel/")
						s.redis.HSet(ctx, taskId, "errorFile", fmt.Sprintf("%v:%v/%v", s.cfg.Intranet.Ip, s.cfg.Application.Port, base))
						colStr, _ := utils.ConvertNumToCol(len(rows[0]) + 1)
						newFile.SetColWidth("Sheet1", "A", colStr, 20)
						if err := newFile.SaveAs(errorFile); err != nil {
							return err
						}

						s.updateLog(logId, bson.M{
							"status":     1,
							"end_time":   time.Now().Unix(),
							"error_file": errorFile,
						})
					} else {
						s.updateLog(logId, bson.M{
							"status":   1,
							"end_time": time.Now().Unix(),
						})
					}
				}
			}
		}
		taskIndex++
		close(doneChan)
	}

	return nil
}

// 获取excel数据所在表格的位置
func (s *Service) getExcelDataAxis(col int, row int) string {
	colStr, _ := utils.ConvertNumToCol(col)
	axis := colStr + strconv.Itoa(row)
	return axis
}

// 获取需要处理的数据行
func (s *Service) handleRows(rows [][]string) [][]string {
	var validRows [][]string
	for i, row := range rows {
		if row == nil || i == 0 {
			continue
		}
		validRows = append(validRows, row)
	}
	return validRows
}

// 生成错误日志文件
func (s *Service) createErrorFile(filePath string) (string, error) {
	errlogDir := "/www/runtime/go-excel/static/" + time.Now().Format("20060102") + "/errlog"
	if err := os.MkdirAll(errlogDir, 0755); err != nil {
		return "", err
	}

	base := path.Base(filePath)
	fileName := errlogDir + "/" + base
	return fileName, nil
}

// 生成excel表头
func (s *Service) generateHeader(row []string, newFile *excelize.File) error {
	for col, colCell := range row {
		axis := s.getExcelDataAxis(col+1, 1)
		newFile.SetCellValue("Sheet1", axis, colCell)
	}

	axis := s.getExcelDataAxis(len(row)+1, 1)
	newFile.SetCellValue("Sheet1", axis, "失败原因")
	return nil
}

// 下载oss文件到本地
func (s *Service) downloadExcel() (string, error) {
	url := s.cfg.Oss.Url + "/" + s.Form.FilePath

	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	filePath, err := s.createDownloadFile(url)
	if err != nil {
		return "", err
	}

	out, err := os.Create(filePath)
	if err != nil {
		return "", err
	}
	defer out.Close()

	// 将file的内容拷贝到out
	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return "", err
	}
	return filePath, nil
}

// 生成下载文件
func (s *Service) createDownloadFile(url string) (string, error) {
	uploadDir := "/www/runtime/go-excel/static/" + time.Now().Format("20060102") + "/upload"
	if err := os.MkdirAll(uploadDir, 0755); err != nil {
		return "", err
	}

	base := path.Base(url)
	ext := path.Ext(base)
	filePath := fmt.Sprintf("%v/%v-%v%v", uploadDir, s.Form.TaskType, time.Now().Unix(), utils.RandStringBytes(5)+ext)
	return filePath, nil
}

// 获取导入任务缓存key
func (s *Service) cacheKey(groupId, areaId, taskType string) string {
	if groupId != "" {
		return fmt.Sprintf("group:%v:type:%v", groupId, taskType)
	}
	if areaId != "" {
		return fmt.Sprintf("area:%v:type:%v", areaId, taskType)
	}
	return taskType
}

// 查询是否存在进行中导入任务
func (s *Service) hasTask(groupId, areaId, taskType string) (bool, string) {
	cacheKey := s.cacheKey(groupId, areaId, taskType)
	taskId, err := s.redis.Get(ctx, cacheKey).Result()
	if err != nil {
		return false, ""
	}
	progress := s.getProgress(taskId)
	rate := progress["rate"]
	if rate == 0 || rate == 100 {
		return false, ""
	}
	return true, taskId
}

// 获取处理进度
func (s *Service) getProgress(taskId string) map[string]interface{} {
	count, err := s.redis.HGet(ctx, taskId, "count").Result()
	if err != nil {
		count = "0"
	}
	countInt, _ := strconv.Atoi(count)
	successCount, err := s.redis.HGet(ctx, taskId, "successCount").Result()
	if err != nil {
		successCount = "0"
	}
	successCountInt, _ := strconv.Atoi(successCount)
	failCount, err := s.redis.HGet(ctx, taskId, "failCount").Result()
	if err != nil {
		failCount = "0"
	}
	failCountInt, _ := strconv.Atoi(failCount)
	done := successCountInt + failCountInt

	var rate int
	if countInt == 0 {
		rate = 0
	} else {
		rateString := fmt.Sprintf("%.2f", float64(done)/float64(countInt))
		rateFloat, _ := strconv.ParseFloat(rateString, 64)
		rate = int(rateFloat * 100)
	}

	errorFile, err := s.redis.HGet(ctx, taskId, "errorFile").Result()
	if err != nil {
		errorFile = ""
	}

	return map[string]interface{}{
		"count":        countInt,
		"successCount": successCountInt,
		"failCount":    failCountInt,
		"rate":         rate,
		"errorFile":    errorFile,
	}
}

//Do 执行任务
func (s *Service) Do(row []string, doneChan chan Result) {
	dataMap := s.buildApiDataMap(row)
	res, err := s.requestApi(dataMap)
	doneChan <- Result{
		row: row,
		res: res,
		err: err,
	}
	return
}

// 构建请求数据
func (s *Service) buildApiDataMap(row []string) map[string]interface{} {
	dataMap := map[string]interface{}{}
	mapping := strings.Split(s.Form.Mapping, ",")
	for k, v := range row {
		dataMap[strings.TrimSpace(mapping[k])] = strings.TrimSpace(v)
	}
	for k, v := range s.Form.ApiParams {
		dataMap[strings.TrimSpace(k)] = strings.TrimSpace(v)
	}
	return dataMap
}

// 调用api接口创建Excel中的数据
func (s *Service) requestApi(dataMap map[string]interface{}) ([]gjson.Result, error) {
	bodyBytes, err := request.Post(s.getApiUrl(), dataMap)
	if err != nil {
		return nil, err
	}

	r := gjson.ParseBytes(bodyBytes)
	code := gjson.Get(r.Raw, "code").String()
	if code != "200" {
		errMsg := gjson.Get(r.Raw, "msg").String()
		return nil, fmt.Errorf(errMsg)
	}
	res := gjson.Get(r.Raw, "data").Array()

	return res, nil
}

// 获取远端api的host地址
func (s *Service) getApiHost(host string) interface{} {
	b, _ := json.Marshal(s.cfg.ApiHost)
	var m map[string]interface{}
	_ = json.Unmarshal(b, &m)
	return m[host]
}

// 获取远端api的完整地址
func (s *Service) getApiUrl() string {
	apiHost := s.getApiHost(s.Form.ApiHost)
	return fmt.Sprintf("%v%v", apiHost, s.Form.ApiPath)
}

func (s *Service) log(f func() (string, [][]string, string, error)) (string, [][]string, string, bson.ObjectId, error) {
	id := bson.NewObjectId()
	collection := s.mongodb.C("import_excel_log")
	err := collection.Insert(map[string]interface{}{
		"_id":        id,
		"params":     s.Form,
		"start_time": time.Now().Unix(),
		"date":       time.Now().In(time.Local).Format("2006-01-02 15:04:05"),
		"status":     0,
	})
	if err != nil {
		return "", nil, "", "", err
	}

	filePath, rows, taskId, err := f()
	if err != nil {
		collection.UpdateId(id,
			bson.M{"$set": bson.M{
				"task_id":   taskId,
				"file_path": filePath,
				"err":       err.Error(),
			}})
	} else {
		collection.UpdateId(id,
			bson.M{"$set": bson.M{
				"task_id":   taskId,
				"file_path": filePath,
			}})
	}
	return filePath, rows, taskId, id, err
}

func (s *Service) updateLog(id bson.ObjectId, update bson.M) error {
	collection := s.mongodb.C("import_excel_log")
	return collection.UpdateId(id, bson.M{"$set": update})
}
